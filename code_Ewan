// CANDY CRUSH IN TERMINAL
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <algorithm>

using namespace std;

typedef vector <unsigned> line; // un type représentant une ligne de la grille
typedef vector <line> mat; // un type représentant la grille

struct maPosition { 
    unsigned abs; // une position dans la girlle
    unsigned ord; // une position dans la grille
}; 

// variables globales

const unsigned KReset   (0);
const unsigned KNoir    (30);
const unsigned KRouge   (31);
const unsigned KVert    (32);
const unsigned KJaune   (33);
const unsigned KBleu    (34);
const unsigned KMAgenta (35);
const unsigned KCyan    (36);
     
const unsigned KNbCandies = 10;

void couleur (const unsigned & coul) {
    cout << "\033[" << coul <<"m";
}

void clearScreen () {
    cout << "\033[H\033[2J";
}

void initGrid (mat & grid, const size_t & matSize) {
    grid.resize(matSize);
    for (size_t i = 0; i < matSize; i = i + 1) {
        grid[i].resize(matSize);

        for (size_t j = 0; j < matSize; j = j + 1) {
            grid[i][j] = rand() % 9 + 1; // valeurs aleatoires entre 1 et 9
        }
    }
}

void  displayGrid (const mat & grid) {
    const size_t matSize = grid.size();
    for (size_t i = 0; i < matSize; ++i) {
        for (size_t j = 0; j < matSize; j = j + 1) {
            couleur(KRouge + grid[i][j] % 7); // couleur en fonction de la valeur
            cout << grid[i][j] << " ";
        }
        cout << endl;
    }
}

void makeAMove (mat & grid, const maPosition & pos, const char & direction) {
    maPosition newPos = pos;
    switch (direction) {
        case 'z':
            if (pos.ord > 0) {
                newPos.ord = pos.ord - 1;
            }
            std::swap(grid[pos.ord][pos.abs], grid[newPos.ord][newPos.abs]);
            break;
        case 's':
            if (pos.ord < grid.size() - 1) {
                newPos.ord = pos.ord + 1;
            }
            swap(grid[pos.ord][pos.abs], grid[newPos.ord][newPos.abs]);
            break;
        case 'q':
            if (pos.abs > 0) {
                newPos.abs = pos.abs - 1;
            }
            swap(grid[pos.ord][pos.abs], grid[newPos.ord][newPos.abs]);
            break;
        case 'd':
            if (pos.abs < grid.size() - 1) {
                newPos.abs = pos.abs + 1;
            }
            swap(grid[pos.ord][pos.abs], grid[newPos.ord][newPos.abs]);
            break;
    }
}

bool atLeastThreeInAColumn (const mat & grid, maPosition & pos, unsigned & howMany) {
    const size_t matSize = grid.size();
    unsigned count = 1;
    unsigned val = grid[pos.ord][pos.abs];

    // On verif si il y a au moins 3 nombres identiques sur la même colonne. 
    // ont renvoie vrai si on trouve bien 3 nombres identiques, sinon on renvoie faux.
    // Si on renvoie vrai, on a une suite de howMany tous égaux à partir des coordonnées pos.
    for (size_t i = pos.ord + 1; i < matSize; i = i + 1) {
        if (grid[i][pos.abs] == val) {
            count = count + 1;
        } else {
            break;
        }
    }
    howMany = count;
    
    if  (howMany >= 3) {
        return true;
    } else {
        return false;
    }
}

bool atLeastThreeInARow (const mat & grid, maPosition & pos, unsigned & howMany) {
    const size_t matSize = grid.size();
    unsigned count = 1;
    unsigned val = grid[pos.ord][pos.abs];

    // On verif si il y a au moins 3 nombres identiques sur la même ligne. 
    // ont renvoie vrai si on trouve bien 3 nombres identiques, sinon on renvoie faux.
    // Si on renvoie vrai, on a une suite de howMany tous égaux à partir des coordonnées pos.
    for (size_t j = pos.abs + 1; j < matSize; j = j + 1) {
        if (grid[pos.ord][j] == val) {
            count = count + 1;
        } else {
            break;
        }
    }
    howMany = count;
    
    if  (howMany >= 3) {
        return true;
    } else {
        return false;
    }
}

void removalInRow (mat & grid, const maPosition & pos, unsigned  howMany) {
    // On veut supprimer howMany elements dans la ligne pos.ord
    for (size_t i = pos.abs; i < pos.abs + howMany; i = i + 1) {
        grid[pos.ord][i] = 'x'; // on remplace par x pour symboliser la suppression
    }
}

int main() {
    mat grid;
    const size_t matSize = KNbCandies;
    maPosition pos = {0, 0};
    char direction;
    unsigned howMany;

    srand(time(0)); // initialisation du générateur de nombres aléatoires

    initGrid(grid, matSize);
    displayGrid(grid);

    cout << "Choisir une position (x, y) entre 0 et " << matSize - 1 << " : ";
    cin >> pos.abs >> pos.ord;

    cout << "Enter direction (z, s, q, d): ";
    cin >> direction;
    makeAMove(grid, pos, direction);
    displayGrid(grid);
    couleur(KReset);

    // appel des fonctions de détection et de suppression
    if (atLeastThreeInARow(grid, pos, howMany)) {
        removalInRow(grid, pos, howMany);
        displayGrid(grid);
        couleur(KReset);
    }

    return 0;
}
