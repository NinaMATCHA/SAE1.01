#include <iostream>
#include <vector>

using namespace std;

const unsigned KMaxTimes (5);
const unsigned KnbCandies(4);
const unsigned KVide(0);

typedef vector <unsigned> line; // un type représentant une ligne de la grille
typedef vector <line> mat; // un type représentant la grille

struct maPosition {
    unsigned abs;
    unsigned ord;
}; // une position dans la grille

void clearScreen () {
    cout << "\033[H\033[2J";
}

const unsigned KRouge   (31);
const unsigned KVert    (32);
const unsigned KBleu    (34);
const unsigned KMAgenta (35);

void couleur (const unsigned & coul) {
    cout << "\033[" << coul <<"m";
}

void initGrid (mat & grid, const size_t & matSize){
    grid.resize(matSize);
    for (size_t i(0); i<matSize; ++i){
        grid[i].resize(matSize);
        for (size_t j(0); j<matSize; ++j){
            grid[i][j] = (rand()%KnbCandies)+1;
        }
    }
}

void  displayGrid (const mat & grid){
    clearScreen();
    // indice d'une couleur dans la liste => couleur d'un nombre de cet indice
    const vector<unsigned> color = {KRouge,KVert,KMAgenta,KBleu};

    cout << "   ";
    for(size_t j=0; j<grid.size(); ++j){
        cout << j << " "; // affiche les indices des colonnes
    }
    cout << endl;
    // sépare les indice des lignes avec '_' répétés deux fois la taille de la matrice
    cout << "   " << string(grid.size()*2, '_') << endl;

    for(size_t i=0; i<grid.size(); ++i){
        cout << i << " |"; // pour les indices des lignes
        for(unsigned candy : grid[i]){
            if(candy == KVide){
                cout << ". "; // affiche un point pour le vide
            }
            else{
                couleur(color[candy-1]); // -1 car les bonbons ne peuvent pas valoir 0 mais les indices de la liste commencent a 0
                cout << candy << " ";
                couleur(0);
            }
        }
        cout << endl;
    }
    cout << endl;
}

// évite les valeurs impossibles a l'entrée des lignes/colonnes
bool isValid(const mat& grid, const maPosition& pos) {
    return pos.ord < grid.size() && pos.abs < grid[0].size();
}

// changer makeAMove de void en maPosition permet de garder la valeur de newPos
maPosition makeAMove (mat & grid, const maPosition & pos, const char & direction){
    maPosition newPos = pos;

    // on évite les débordements en plus de changer pos
    if (direction == 'z' && pos.ord > 0) --newPos.ord;
    else if (direction == 's' && pos.ord < grid.size() - 1) ++newPos.ord;
    else if (direction == 'a' && pos.abs > 0) --newPos.abs;
    else if (direction == 'e' && pos.abs < grid.size() - 1) ++newPos.abs;

    // fonction swap pour échanger directement
    swap(grid[pos.ord][pos.abs], grid[newPos.ord][newPos.abs]);
    return newPos;
}

// ---------------------------------------------------------

bool atLeastThreeInAColumn (const mat & grid, maPosition & pos, unsigned & howMany){
    howMany = 1; //on compte le bonbon sur la position aussi
    unsigned nbCandy = grid[pos.ord][pos.abs];
    if (nbCandy == KVide) return false; // pas de points sur les cases vides

    // on verifie en haut
    unsigned li = pos.ord;
    while (li > 0 && grid[li-1][pos.abs] == nbCandy){
        ++howMany;
        --li;
    }

    // en bas
    li = pos.ord;
    while (li < grid.size() - 1 && grid[li+1][pos.abs] == nbCandy){
        ++howMany;
        ++li;
    }

    return (howMany >= 3);
}

bool atLeastThreeInARow (const mat & grid, maPosition & pos, unsigned & howMany){
    howMany = 1;
    unsigned nbCandy = grid[pos.ord][pos.abs];
    if (nbCandy == KVide) return false;

    // on verifie a gauche
    unsigned col = pos.abs;
    while (col > 0 && grid[pos.ord][col-1] == nbCandy){
        ++howMany;
        --col;
    }

    // a droite
    col = pos.abs;
    while (col < grid[0].size() - 1 && grid[pos.ord][col+1] == nbCandy){
        ++howMany;
        ++col;
    }

    return (howMany >= 3);
}

void removalInColumn (mat & grid, maPosition & pos, const unsigned & howMany, const unsigned & begin){    // on enleve de la colonne pos.abs les nb identiques
    if(begin>0){ //begin est un unsigned donc on vérfie qu'il ne crée pas d'erreurs
        for(unsigned i(begin-1); i>0; --i){//on fait tomber a partir du debut de la ligne a effacer
            grid[i + howMany-1][pos.abs]=grid[i-1][pos.abs];
        }
    }

    //Mode infini ?
     for(unsigned i(0); i < howMany; ++i){ //remet des bonbons
         grid[i][pos.abs] = (rand() % KnbCandies) + 1;
     }
}

void removalInRow (mat & grid, maPosition & pos, const unsigned & howMany, const unsigned & begin){ // on enleve de la colonne pos.abs les nb identiques
    for (unsigned j = begin; j < begin + howMany; ++j) {
        // On fait descendre tous les bonbons au-dessus
        for (unsigned i = pos.ord; i > 0; --i) {
            grid[i][j] = grid[i - 1][j];
        }

        grid[0][j] = (rand() % KnbCandies) + 1;
    }
}

int main(){
    //--------------TEST ------------
    mat matrice;
    initGrid(matrice,6);

    // on initialise la grille du jeu ainsi que le nombre de coup maximal;
    cout << "Nombres de coup max : " << KMaxTimes;
    unsigned coups = 0;
    char direction;
    unsigned howMany, begin, nbPos;
    unsigned score = 0;
    // affiche un petit menu donnant les consignes de déplacement;
    cout << "Voici vos déplacements :" << endl << "z : haut" << endl << "s : bas" << endl << "a : gauche" << endl << "e : droite" << endl;
    // on entre dans une boucle tant qu’on n’a pas atteint le nombre maximal de coups :
    while(coups <= KMaxTimes){
        ++coups;
        displayGrid(matrice); // affiche la grille;
        // saisit les coordonnées du nombre à deplacer ainsi que le déplacement souhaité;
        maPosition pos;
        cout << "Entrez les coordonnées du nombre à déplacer :" << endl << "Colonne :";
        cin >> pos.abs;
        cout << "Ligne :";
        cin >> pos.ord;
        nbPos = matrice[pos.ord][pos.abs];
        cout << "Ou voulez vous aller ? ( Utilisez les commandes de déplacement )" << endl;
        cin >> direction;

        // fait les tests de suppression en ligne / colonne et fait les supp si besoin;
        makeAMove(matrice,pos,direction);
        if(atLeastThreeInAColumn(matrice, pos, howMany, begin)){
            removalInColumn(matrice, pos, howMany, begin);
            score += nbPos * howMany;
        }
        if(atLeastThreeInARow(matrice, pos, howMany, begin)){
            removalInRow(matrice, pos, howMany, begin);
            score += nbPos * howMany;
        }
        cout << "Score actuel : " << score << endl;  //affiche le score actuel
    }
    // affiche le score final
    cout << "Votre score final est : " << score;
}
